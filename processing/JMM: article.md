# JMM: Under the mystery

并发，可以说是所有的开发者都绕不开的一个问题，能否写出正确运行的并发安全的代码，也是用来核查一个开发者功力的方式或者说标准。而作为Javaer，随之而来的就是Java Memory Model，也就是JMM，国内互联网上对于JMM的各项讨论可以说众说纷纭，但是实际上点出的内容也是大同小异，这一点也可以从八股文上多少看出些端倪。而JMM之所以如此重要，是因为它是一个极其抽象的概念，JVM实际上算是JMM的一部分实现，或者说JVM实现了部分符合JMM标准的东西。其实大多数时候，我们也并不是特别需要学习这些虚无缥缈的东西，但是做一些了解也不是坏事。

实际上，JMM是一个非常学术性的规范，比如说在Java Language Specification的第17章就有一些对它的介绍，大名鼎鼎的Doug Lea也有一篇针对JMM的JSR-133 Cookbook，还有各路Java Champion做出的演讲和博客等等。实际上本篇文章的内容也基本是出自这些可以在网络上查找到的内容中，结合自己的理解，做出一个我自己的解释和理解。实际上，从去年开始，我就有做出类似的事情，而当时没有及时的将我的想法记录下来，也算是因为功力问题，没有太好的理解。而到了今天，自认为有了些许见解，刚好趁着最近的势头再水一篇文章，希望对大家有所帮助。

再次声明，本文内容仅供参考，大家也不要认为我说的都是对的，如果有不同的意见或者见解，可以通过私人微信或者直接留言讨论即可。



## JMM: Definition

// ---- From Jenkov

简单来说，JMM，实际上指定了JVM如何和计算机的RAM，也就是内存进行合作。而JVM实际上的设计目的也是作为一个virtual machine，对于Java应用来说，JVM就是机器，所以JVM也是一个和计算机有关的模型，这个模型就是JMM。

JMM实际上指定了，不同的线程，在什么时候、通过什么方式可以看到其他线程写入的共享变量的值。



// ---- From Aleksey

在具体介绍之前，我们先来看个简单的例子，假设有这么个方法：

```java
int returnNumber42() {
  int a = 21;
  int b = 21;
  return a + b;
}
```

我们这个方法的意图，就像是方法名所声明的一样，最终是为了获取一个值为42的数字，而如果直接将这个方法转换成字节码，那么我们可以得到类似如下的步骤：

1. 将21放入到寄存器1
2. 将21放入到寄存器2
3. 将两个寄存器的内容相加
4. 返回结果

可以看到，我们只需要一个42，但是却涉及到这么多的操作，这都是因为我们写出了不高效的代码。而Java语言之所以能在现在仍然成为主流，就是因为JVM会帮我们尽量做出足够的优化来尽可能的提高我们的Java代码的运行性能。就像这个方法，既然我们只需要一个42，那么不如直接：

1. 将42直接返回

如此一来，就直接将我们程序员的意图实现了，并且将性能提升到了另一个level。

